<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Life Adventurer - Portal</title>

    <link rel="icon" href="./images/lifeadventurer_rounded_logo.png" />

    <style>
      /* Base styles for light mode */
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
          "Segoe UI Symbol";
        line-height: 1.6;
        margin: 0;
        padding: 0;
        background-color: #f8f9fa; /* Fallback background */
        color: #212529;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        transition:
          background-color 0.3s ease,
          color 0.3s ease;
        overflow: hidden; /* Hide scrollbars if canvas is slightly larger */
        /* Theming tokens */
        --container-bg: rgba(255, 255, 255, 0.7);
        --container-border: rgba(0, 0, 0, 0.08);
        --heading-gradient: linear-gradient(90deg, #212529, #0d6efd);
        --link-bg: rgba(233, 236, 239, 0.7);
        --link-border: rgba(13, 110, 253, 0.15);
        --link-color: #0d6efd;
        --link-hover-bg: rgba(13, 110, 253, 0.9);
        --link-hover-color: #ffffff;
        --shadow-color: rgba(0, 0, 0, 0.12);
      }

      #hexagon-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Behind all other content */
      }

      .container {
        background-color: var(--container-bg);
        padding: 30px 40px;
        border-radius: 16px;
        border: 1px solid var(--container-border);
        box-shadow: 0 12px 30px var(--shadow-color);
        max-width: 600px;
        width: 100%;
        text-align: center;
        position: relative; /* For positioning the theme toggle button and ensuring it's above canvas */
        z-index: 1; /* Above canvas */
        transition:
          background-color 0.3s ease,
          box-shadow 0.3s ease,
          border-color 0.3s ease;
        -webkit-backdrop-filter: blur(10px) saturate(140%);
        backdrop-filter: blur(10px) saturate(140%);
      }

      .avatar {
        width: 96px;
        height: 96px;
        margin: 10px auto 14px;
        border-radius: 50%;
        padding: 3px;
        background: linear-gradient(135deg, #0d6efd, #6f42c1, #20c997);
        box-shadow: 0 8px 20px var(--shadow-color);
      }

      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
        display: block;
      }

      h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        color: #343a40;
        background: var(--heading-gradient);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        transition: color 0.3s ease;
      }

      p.subtitle {
        font-size: 1.1em;
        color: #6c757d;
        margin-bottom: 30px;
        transition: color 0.3s ease;
      }

      ul.links {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      ul.links li {
        margin-bottom: 15px;
      }

      ul.links a {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 16px;
        background-color: var(--link-bg);
        color: var(--link-color);
        text-decoration: none;
        border-radius: 12px;
        border: 1px solid var(--link-border);
        font-size: 1.05em;
        transition:
          background-color 0.2s ease-in-out,
          color 0.2s ease-in-out,
          transform 0.15s ease,
          box-shadow 0.2s ease-in-out,
          border-color 0.2s ease-in-out;
        box-shadow: 0 4px 10px var(--shadow-color);
      }

      ul.links a:hover,
      ul.links a:focus {
        background-color: var(--link-hover-bg);
        color: var(--link-hover-color);
        outline: none;
        transform: translateY(-1px);
        box-shadow: 0 8px 18px var(--shadow-color);
      }

      ul.links a .link-left {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      ul.links a svg {
        width: 20px;
        height: 20px;
        flex: 0 0 20px;
      }

      ul.links a .link-arrow {
        transition: transform 0.2s ease;
      }

      ul.links a:hover .link-arrow,
      ul.links a:focus .link-arrow {
        transform: translateX(2px) translateY(-2px) rotate(10deg);
      }

      .footer {
        margin-top: 30px;
        font-size: 0.9em;
        color: #6c757d;
        transition: color 0.3s ease;
      }

      .theme-toggle-button {
        position: absolute;
        top: 15px;
        right: 15px;
        background-color: #e9ecef;
        color: #495057;
        border: 1px solid #ced4da;
        padding: 10px;
        border-radius: 999px;
        cursor: pointer;
        font-size: 0.95em;
        z-index: 2; /* Above container's content if needed */
        transition:
          background-color 0.2s ease,
          color 0.2s ease,
          border-color 0.2s ease,
          transform 0.15s ease;
        box-shadow: 0 6px 14px var(--shadow-color);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .theme-toggle-button:hover {
        background-color: #ced4da;
        transform: translateY(-1px);
      }

      /* Dark mode styles */
      body.dark-mode {
        background-color: #121212;
        color: #e0e0e0;
        --container-bg: rgba(30, 30, 30, 0.6);
        --container-border: rgba(255, 255, 255, 0.06);
        --heading-gradient: linear-gradient(90deg, #e9ecef, #74c0fc);
        --link-bg: rgba(52, 58, 64, 0.7);
        --link-border: rgba(128, 189, 255, 0.18);
        --link-color: #80bdff;
        --link-hover-bg: rgba(73, 80, 87, 0.95);
        --link-hover-color: #ffffff;
        --shadow-color: rgba(0, 0, 0, 0.45);
      }

      body.dark-mode .container {
        background-color: rgba(30, 30, 30, 0.9); /* Slightly transparent dark */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }

      

      body.dark-mode p.subtitle {
        color: #adb5bd;
      }

      body.dark-mode ul.links a {
        background-color: var(--link-bg);
        color: var(--link-color);
        border-color: var(--link-border);
      }

      body.dark-mode ul.links a:hover,
      body.dark-mode ul.links a:focus {
        background-color: #495057;
        color: #ffffff;
      }

      body.dark-mode .footer {
        color: #adb5bd;
      }

      body.dark-mode .theme-toggle-button {
        background-color: #343a40;
        color: #e0e0e0;
        border-color: #495057;
      }

      body.dark-mode .theme-toggle-button:hover {
        background-color: #495057;
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        h1 {
          font-size: 2em;
        }
        .container {
          padding: 30px 25px;
        }
        ul.links a {
          padding: 12px 14px;
          font-size: 1em;
        }
        .theme-toggle-button {
          top: 10px;
          right: 10px;
          padding: 6px 10px;
        }
      }

      /* Focus styles for accessibility */
      :focus-visible {
        outline: 2px solid #0d6efd;
        outline-offset: 2px;
      }

      /* Subtle entrance animations */
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .avatar,
      h1,
      p.subtitle,
      .links li,
      .footer {
        animation: fadeInUp 0.45s ease both;
      }

      .links li:nth-child(1) {
        animation-delay: 0.05s;
      }
      .links li:nth-child(2) {
        animation-delay: 0.1s;
      }
      .links li:nth-child(3) {
        animation-delay: 0.15s;
      }

      /* Respect reduced motion preferences */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
        }
      }
    </style>
  </head>

  <body>
    <canvas id="hexagon-canvas"></canvas>

    <div class="container">
      <button class="theme-toggle-button" id="themeToggle" aria-label="Toggle color theme" title="Toggle theme">
        üåô <span class="toggle-label">Dark</span>
      </button>

      <div class="avatar" aria-hidden="true">
        <img src="./images/lifeadventurer.jpg" alt="" />
      </div>

      <h1>Life Adventurer</h1>

      <p class="subtitle">
        Welcome to my personal portal. Find my projects and resources below.
      </p>

      <ul class="links">
        <li>
          <a
            href="https://sharacle.com"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Open Sharacle in a new tab"
          >
            <span class="link-left">
              <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
              </svg>
              <span class="link-text">Sharacle</span>
            </span>
            <svg class="link-arrow" aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 17L17 7"></path>
              <path d="M7 7h10v10"></path>
            </svg>
          </a>
        </li>

        <li>
          <a href="/wiki/" target="_blank" rel="noopener noreferrer" aria-label="Open My Wiki in a new tab">
            <span class="link-left">
              <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                <path d="M20 22H6.5a2.5 2.5 0 1 1 0-5H20v5z"></path>
                <path d="M4 4v15"></path>
                <path d="M20 4v9"></path>
                <path d="M8 4h8"></path>
              </svg>
              <span class="link-text">My Wiki</span>
            </span>
            <svg class="link-arrow" aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 17L17 7"></path>
              <path d="M7 7h10v10"></path>
            </svg>
          </a>
        </li>

        <li>
          <a
            href="https://github.com/LifeAdventurer"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Open GitHub Profile in a new tab"
          >
            <span class="link-left">
              <svg aria-hidden="true" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C6.48 2 2 6.58 2 12.26c0 4.5 2.87 8.31 6.84 9.66.5.09.68-.22.68-.49 0-.24-.01-.88-.01-1.72-2.78.62-3.37-1.37-3.37-1.37-.46-1.19-1.12-1.51-1.12-1.51-.92-.64.07-.63.07-.63 1.02.07 1.55 1.07 1.55 1.07.9 1.58 2.36 1.12 2.94.85.09-.67.35-1.12.63-1.38-2.22-.26-4.56-1.15-4.56-5.11 0-1.13.39-2.06 1.03-2.79-.1-.26-.45-1.3.1-2.72 0 0 .84-.27 2.75 1.06A9.32 9.32 0 0 1 12 6.83c.85 0 1.71.12 2.51.35 1.9-1.33 2.74-1.06 2.74-1.06.55 1.42.2 2.46.1 2.72.64.73 1.03 1.66 1.03 2.79 0 3.97-2.34 4.84-4.57 5.1.36.32.67.95.67 1.92 0 1.39-.01 2.51-.01 2.85 0 .27.18.58.69.48A10.04 10.04 0 0 0 22 12.26C22 6.58 17.52 2 12 2Z"></path>
              </svg>
              <span class="link-text">GitHub Profile</span>
            </span>
            <svg class="link-arrow" aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 17L17 7"></path>
              <path d="M7 7h10v10"></path>
            </svg>
          </a>
        </li>
      </ul>

      <div class="footer">
        <p>
          &copy; <span id="currentYear"></span> Life Adventurer. All rights
          reserved.
        </p>
      </div>
    </div>

    <script>
      // --- THEME TOGGLE SCRIPT ---
      document.getElementById("currentYear").textContent =
        new Date().getFullYear();
      const themeToggle = document.getElementById("themeToggle");
      const body = document.body;
      const prefersDarkScheme = window.matchMedia(
        "(prefers-color-scheme: dark)",
      );
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)",
      );

      function applyTheme(theme) {
        if (theme === "dark") {
          body.classList.add("dark-mode");
          themeToggle.innerHTML = "‚òÄÔ∏è <span class=\"toggle-label\">Light</span>";
        } else {
          body.classList.remove("dark-mode");
          themeToggle.innerHTML = "üåô <span class=\"toggle-label\">Dark</span>";
        }
        if (
          window.hexagonApp &&
          typeof window.hexagonApp.updateTheme === "function"
        ) {
          window.hexagonApp.updateTheme(theme);
        }
      }

      function toggleTheme() {
        let newTheme = body.classList.contains("dark-mode") ? "light" : "dark";
        applyTheme(newTheme);
        localStorage.setItem("theme", newTheme);
      }

      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) {
        applyTheme(savedTheme);
      } else {
        applyTheme(prefersDarkScheme.matches ? "dark" : "light");
      }

      themeToggle.addEventListener("click", toggleTheme);
      prefersDarkScheme.addEventListener("change", (e) => {
        if (!localStorage.getItem("theme")) {
          applyTheme(e.matches ? "dark" : "light");
        }
      });

      // --- HEXAGON BACKGROUND SCRIPT ---
      window.hexagonApp = (function () {
        const canvas = document.getElementById("hexagon-canvas");
        const ctx = canvas.getContext("2d");

        let width, height;
        const hexSize = 30; // Size of the hexagon (radius)
        const hexWidth = Math.sqrt(3) * hexSize;
        const hexHeight = 2 * hexSize;
        const animationSpeed = 0.08; // How fast the color changes (0 to 1)
        const fadeDelay = 800; // ms to wait before fading back

        let hexagons = [];
        let lastHoveredHex = null; // Track the previously hovered hexagon

        // Animation control respecting reduced motion
        let animationEnabled = !prefersReducedMotion.matches;
        let animationFrameId = null;

        // Theme-dependent colors
        let baseHexColor = "#e0e0e0"; // Light mode default
        let hoverHexColor = "#a0c4ff"; // Light mode hover
        let currentTheme = "light";

        // Virtual Mouse specific variables
        let virtualMouseX; // Will be initialized to center
        let virtualMouseY; // Will be initialized to center
        let virtualMouseSpeed = 2; // Pixels per frame
        let virtualMouseDirectionX = Math.random() > 0.5 ? 1 : -1; // Random initial direction
        let virtualMouseDirectionY = Math.random() > 0.5 ? 1 : -1; // Random initial direction
        const virtualMouseChangeDirectionInterval = 120; // How often to change direction (in animation frames, ~2 seconds at 60fps)
        let virtualMouseFrameCounter = 0;

        // A flag to know if the real mouse has moved recently
        let realMouseActive = false;
        let realMouseInactivityTimer;
        const realMouseInactivityThreshold = 3000; // ms before virtual mouse takes over

        function hexToRgb(hex) {
          var r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
          return { r, g, b };
        }

        function updateThemeColors(theme) {
          currentTheme = theme;
          if (theme === "dark") {
            baseHexColor = "#333333";
            hoverHexColor = "#5870a1";
          } else {
            baseHexColor = "#e0e0e0";
            hoverHexColor = "#a0c4ff";
          }
          hexagons.forEach((hex) => {
            hex.baseColorRgb = hexToRgb(baseHexColor);
            hex.hoverColorRgb = hexToRgb(hoverHexColor);
            // Ensure current color matches base color immediately on theme change
            hex.color = baseHexColor;
            hex.targetColorRgb = hex.baseColorRgb; // Reset target
            hex.animationProgress = 0; // Start animation from base
          });
        }

        class Hexagon {
          constructor(x, y, q, r) {
            this.x = x;
            this.y = y;
            this.q = q;
            this.r = r;
            this.baseColorRgb = hexToRgb(baseHexColor);
            this.hoverColorRgb = hexToRgb(hoverHexColor);

            this.color = baseHexColor; // Current rendered color (hex string)
            this.targetColorRgb = this.baseColorRgb; // Target color for animation (RGB object)
            this.animationProgress = 0; // 0 = fully base, 1 = fully hover
            this.lastInteractionTime = 0; // To handle fade delay
          }

          draw() {
            ctx.fillStyle = this.color; // Use the interpolated color
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i + Math.PI / 6; // Rotated for flat top
              const pointX = this.x + hexSize * Math.cos(angle);
              const pointY = this.y + hexSize * Math.sin(angle);
              if (i === 0) ctx.moveTo(pointX, pointY);
              else ctx.lineTo(pointX, pointY);
            }
            ctx.closePath();
            ctx.fill();
          }

          update() {
            const now = Date.now();

            // If currently aiming for hover color, increase progress
            if (this.targetColorRgb === this.hoverColorRgb) {
              this.animationProgress = Math.min(
                1,
                this.animationProgress + animationSpeed,
              );
            } else {
              // If aiming for base color, decrease progress after a delay
              if (now - this.lastInteractionTime > fadeDelay) {
                this.animationProgress = Math.max(
                  0,
                  this.animationProgress - animationSpeed,
                );
              }
            }

            // Interpolate color from base to hover (or vice-versa) based on progress
            const startRgb = this.baseColorRgb;
            const endRgb = this.hoverColorRgb;

            const r = Math.round(
              startRgb.r + (endRgb.r - startRgb.r) * this.animationProgress,
            );
            const g = Math.round(
              startRgb.g + (endRgb.g - startRgb.g) * this.animationProgress,
            );
            const b = Math.round(
              startRgb.b + (endRgb.b - startRgb.b) * this.animationProgress,
            );
            this.color = `rgb(${r},${g},${b})`;
          }

          // Optimized hit test: Check bounding box first, then actual hexagon
          isMouseOver(mx, my) {
            // Bounding box quick check
            if (
              mx < this.x - hexWidth / 2 ||
              mx > this.x + hexWidth / 2 ||
              my < this.y - hexHeight / 2 ||
              my > this.y + hexHeight / 2
            ) {
              return false;
            }
            // More accurate hexagon check
            const dx = Math.abs(mx - this.x);
            const dy = Math.abs(my - this.y);
            if (dx > hexWidth / 2 || dy > hexHeight / 2) return false;
            return (
              dy <= hexSize * 0.75 &&
              dx <= hexWidth / 2 &&
              (hexSize * 0.75 - dy) * Math.sqrt(3) > dx - hexSize * 0.5
            );
          }

          setHover(isHovered) {
            if (isHovered) {
              this.targetColorRgb = this.hoverColorRgb;
              this.lastInteractionTime = Date.now();
            } else {
              this.targetColorRgb = this.baseColorRgb;
            }

            // If reduced motion is requested, jump colors immediately
            if (prefersReducedMotion.matches) {
              this.animationProgress = isHovered ? 1 : 0;
              const rgb = isHovered ? this.hoverColorRgb : this.baseColorRgb;
              this.color = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
            }
          }
        }

        function initHexagons() {
          hexagons = []; // Add padding to avoid gaps at edges
          const paddingX = hexWidth;
          const paddingY = hexHeight;

          const startX = -paddingX;
          const endX = width + paddingX;
          const startY = -paddingY;
          const endY = height + paddingY;

          // Offset rows for tessellation (odd-r offset)
          for (let r = 0; ; r++) {
            const y = r * hexHeight * 0.75;
            if (y - hexHeight > endY) break;

            for (let q = 0; ; q++) {
              const xOffset = r % 2 === 0 ? 0 : hexWidth / 2;
              const x = q * hexWidth + xOffset;
              if (x - hexWidth > endX) break;
              hexagons.push(new Hexagon(x, y, q, r));
            }
          }
        }

        function resizeCanvas() {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
          initHexagons(); // Re-initialize hexagons on resize
          updateThemeColors(currentTheme); // Apply current theme colors
          // Re-center virtual mouse on resize
          virtualMouseX = width / 2;
          virtualMouseY = height / 2;
        }

        // Centralized function to handle pointer position updates
        function updateHoveredHexagon(x, y) {
          let currentHoveredHex = null;
          for (let i = 0; i < hexagons.length; i++) {
            if (hexagons[i].isMouseOver(x, y)) {
              currentHoveredHex = hexagons[i];
              break; // Found it, no need to check others
            }
          }

          if (currentHoveredHex && currentHoveredHex !== lastHoveredHex) {
            if (lastHoveredHex) {
              lastHoveredHex.setHover(false); // Tell the previous one to fade out
            }
            currentHoveredHex.setHover(true); // Tell the new one to highlight
            lastHoveredHex = currentHoveredHex;
          } else if (!currentHoveredHex && lastHoveredHex) {
            // Mouse left the last hovered hexagon
            lastHoveredHex.setHover(false);
            lastHoveredHex = null;
          }
        }

        function animate() {
          ctx.clearRect(0, 0, width, height);

          if (!realMouseActive) {
            // Only update virtual mouse if real mouse is inactive
            virtualMouseFrameCounter++;
            if (
              virtualMouseFrameCounter >= virtualMouseChangeDirectionInterval
            ) {
              virtualMouseDirectionX = Math.random() > 0.5 ? 1 : -1;
              virtualMouseDirectionY = Math.random() > 0.5 ? 1 : -1;
              virtualMouseFrameCounter = 0;
            }

            // Move virtual mouse
            virtualMouseX += virtualMouseSpeed * virtualMouseDirectionX;
            virtualMouseY += virtualMouseSpeed * virtualMouseDirectionY;

            // Boundary checks for virtual mouse
            if (virtualMouseX < 0 || virtualMouseX > width) {
              virtualMouseDirectionX *= -1;
              virtualMouseX = Math.max(0, Math.min(width, virtualMouseX)); // Clamp within bounds
            }
            if (virtualMouseY < 0 || virtualMouseY > height) {
              virtualMouseDirectionY *= -1;
              virtualMouseY = Math.max(0, Math.min(height, virtualMouseY)); // Clamp within bounds
            }

            updateHoveredHexagon(virtualMouseX, virtualMouseY);
          }

          hexagons.forEach((hex) => {
            hex.update(); // Update color/animation state
            hex.draw();
          });

          animationFrameId = requestAnimationFrame(animate);
        }

        function drawOnce() {
          ctx.clearRect(0, 0, width, height);
          hexagons.forEach((hex) => {
            hex.draw();
          });
        }

        function startAnimation() {
          if (animationFrameId !== null) return;
          animationEnabled = true;
          animationFrameId = requestAnimationFrame(animate);
        }

        function stopAnimation() {
          if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          animationEnabled = false;
          drawOnce();
        }

        window.addEventListener("resize", resizeCanvas);

        document.addEventListener("mousemove", (e) => {
          // Reset inactivity timer and set real mouse as active
          clearTimeout(realMouseInactivityTimer);
          realMouseActive = true;
          updateHoveredHexagon(e.clientX, e.clientY);

          // Set a timeout to switch back to virtual mouse if no movement occurs
          realMouseInactivityTimer = setTimeout(() => {
            realMouseActive = false;
            // When switching back, set virtual mouse to current real mouse position
            virtualMouseX = e.clientX;
            virtualMouseY = e.clientY;
          }, realMouseInactivityThreshold);
        });

        // Initialize on load
        const initialTheme =
          localStorage.getItem("theme") ||
          (prefersDarkScheme.matches ? "dark" : "light");
        resizeCanvas(); // This calls initHexagons and sets initial colors and centers virtual mouse
        updateThemeColors(initialTheme); // Ensure colors are set immediately after init
        if (animationEnabled) {
          startAnimation();
        } else {
          drawOnce();
        }

        return {
          updateTheme: updateThemeColors, // Expose function to update theme colors
          start: startAnimation,
          stop: stopAnimation,
        };
      })();

      // React to reduced motion preference changes
      prefersReducedMotion.addEventListener("change", (e) => {
        const reduce = e.matches;
        if (!window.hexagonApp) return;
        if (reduce) {
          window.hexagonApp.stop();
        } else {
          window.hexagonApp.start();
        }
      });
    </script>
  </body>
</html>
