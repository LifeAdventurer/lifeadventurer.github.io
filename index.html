<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Life Adventurer - Portal</title>

    <style>
      /* Base styles for light mode */
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
          "Segoe UI Symbol";
        line-height: 1.6;
        margin: 0;
        padding: 0;
        background-color: #f8f9fa; /* Fallback background */
        color: #212529;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        transition:
          background-color 0.3s ease,
          color 0.3s ease;
        overflow: hidden; /* Hide scrollbars if canvas is slightly larger */
      }

      #hexagon-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Behind all other content */
      }

      .container {
        background-color: rgba(
          255,
          255,
          255,
          0.9
        ); /* Slightly transparent white */
        padding: 30px 40px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        max-width: 600px;
        width: 100%;
        text-align: center;
        position: relative; /* For positioning the theme toggle button and ensuring it's above canvas */
        z-index: 1; /* Above canvas */
        transition:
          background-color 0.3s ease,
          box-shadow 0.3s ease;
      }

      h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        color: #343a40;
        transition: color 0.3s ease;
      }

      p.subtitle {
        font-size: 1.1em;
        color: #6c757d;
        margin-bottom: 30px;
        transition: color 0.3s ease;
      }

      ul.links {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      ul.links li {
        margin-bottom: 15px;
      }

      ul.links a {
        display: block;
        padding: 15px 20px;
        background-color: #e9ecef;
        color: #007bff;
        text-decoration: none;
        border-radius: 5px;
        font-size: 1.1em;
        transition:
          background-color 0.2s ease-in-out,
          color 0.2s ease-in-out;
      }

      ul.links a:hover,
      ul.links a:focus {
        background-color: #007bff;
        color: #ffffff;
        outline: none;
      }

      .footer {
        margin-top: 30px;
        font-size: 0.9em;
        color: #6c757d;
        transition: color 0.3s ease;
      }

      .theme-toggle-button {
        position: absolute;
        top: 15px;
        right: 15px;
        background-color: #e9ecef;
        color: #495057;
        border: 1px solid #ced4da;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.9em;
        z-index: 2; /* Above container's content if needed */
        transition:
          background-color 0.2s ease,
          color 0.2s ease,
          border-color 0.2s ease;
      }

      .theme-toggle-button:hover {
        background-color: #ced4da;
      }

      /* Dark mode styles */
      body.dark-mode {
        background-color: #121212;
        color: #e0e0e0;
      }

      body.dark-mode .container {
        background-color: rgba(30, 30, 30, 0.9); /* Slightly transparent dark */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }

      body.dark-mode h1 {
        color: #f8f9fa;
      }

      body.dark-mode p.subtitle {
        color: #adb5bd;
      }

      body.dark-mode ul.links a {
        background-color: #343a40;
        color: #80bdff;
      }

      body.dark-mode ul.links a:hover,
      body.dark-mode ul.links a:focus {
        background-color: #495057;
        color: #ffffff;
      }

      body.dark-mode .footer {
        color: #adb5bd;
      }

      body.dark-mode .theme-toggle-button {
        background-color: #343a40;
        color: #e0e0e0;
        border-color: #495057;
      }

      body.dark-mode .theme-toggle-button:hover {
        background-color: #495057;
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        h1 {
          font-size: 2em;
        }
        .container {
          padding: 30px 25px;
        }
        ul.links a {
          padding: 12px 15px;
          font-size: 1em;
        }
        .theme-toggle-button {
          top: 10px;
          right: 10px;
          padding: 6px 10px;
        }
      }
    </style>
  </head>

  <body>
    <canvas id="hexagon-canvas"></canvas>

    <div class="container">
      <button class="theme-toggle-button" id="themeToggle">Toggle Theme</button>

      <h1>Life Adventurer</h1>

      <p class="subtitle">
        Welcome to my personal portal. Find my projects and resources below.
      </p>

      <ul class="links">
        <li>
          <a
            href="https://sharacle.com"
            target="_blank"
            rel="noopener noreferrer"
            >Sharacle</a
          >
        </li>

        <li>
          <a href="/wiki/" target="_blank" rel="noopener noreferrer">My Wiki</a>
        </li>

        <li>
          <a
            href="https://github.com/LifeAdventurer"
            target="_blank"
            rel="noopener noreferrer"
            >GitHub Profile</a
          >
        </li>
      </ul>

      <div class="footer">
        <p>
          &copy; <span id="currentYear"></span> Life Adventurer. All rights
          reserved.
        </p>
      </div>
    </div>

    <script>
      // --- THEME TOGGLE SCRIPT ---
      document.getElementById("currentYear").textContent =
        new Date().getFullYear();
      const themeToggle = document.getElementById("themeToggle");
      const body = document.body;
      const prefersDarkScheme = window.matchMedia(
        "(prefers-color-scheme: dark)",
      );

      function applyTheme(theme) {
        if (theme === "dark") {
          body.classList.add("dark-mode");
          themeToggle.textContent = "☀️ Light";
        } else {
          body.classList.remove("dark-mode");
          themeToggle.textContent = "🌙 Dark";
        } // Notify hexagon script about theme change
        if (
          window.hexagonApp &&
          typeof window.hexagonApp.updateTheme === "function"
        ) {
          window.hexagonApp.updateTheme(theme);
        }
      }

      function toggleTheme() {
        let newTheme = body.classList.contains("dark-mode") ? "light" : "dark";
        applyTheme(newTheme);
        localStorage.setItem("theme", newTheme);
      }

      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) {
        applyTheme(savedTheme);
      } else {
        applyTheme(prefersDarkScheme.matches ? "dark" : "light");
      }

      themeToggle.addEventListener("click", toggleTheme);
      prefersDarkScheme.addEventListener("change", (e) => {
        if (!localStorage.getItem("theme")) {
          applyTheme(e.matches ? "dark" : "light");
        }
      });
      // --- HEXAGON BACKGROUND SCRIPT ---

      window.hexagonApp = (function () {
        const canvas = document.getElementById("hexagon-canvas");
        const ctx = canvas.getContext("2d");

        let width, height;
        const hexSize = 30;
        const hexWidth = Math.sqrt(3) * hexSize;
        const hexHeight = 2 * hexSize;
        const animationSpeed = 0.08;
        const fadeDelay = 800;

        let hexagons = [];
        let mouseX = -1000,
          mouseY = -1000;
        let lastHoveredHex = null;

        let baseHexColor = "#e0e0e0";
        let hoverHexColor = "#a0c4ff";
        let currentTheme = "light";

        // Virtual Mouse specific variables
        let virtualMouseX = -1;
        let virtualMouseY = -1;
        let virtualMouseSpeed = 2; // Pixels per frame
        let virtualMouseDirectionX = 1; // 1 or -1
        let virtualMouseDirectionY = 1; // 1 or -1
        let virtualMouseUpdateInterval = 50; // How often to change direction (in animation frames)
        let virtualMouseUpdateCounter = 0;

        function hexToRgb(hex) {
          var r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
          return { r, g, b };
        }

        function updateThemeColors(theme) {
          currentTheme = theme;
          if (theme === "dark") {
            baseHexColor = "#333333";
            hoverHexColor = "#5870a1";
          } else {
            baseHexColor = "#e0e0e0";
            hoverHexColor = "#a0c4ff";
          }
          hexagons.forEach((hex) => {
            hex.baseColorRgb = hexToRgb(baseHexColor);
            hex.hoverColorRgb = hexToRgb(hoverHexColor);
            hex.color = baseHexColor;
            hex.targetColorRgb = hex.toBaseColor(); // Set target back to base immediately
            hex.animationProgress = 0; // Ensure it animates from base
          });
        }

        class Hexagon {
          constructor(x, y, q, r) {
            this.x = x;
            this.y = y;
            this.q = q;
            this.r = r;
            this.baseColorRgb = hexToRgb(baseHexColor);
            this.hoverColorRgb = hexToRgb(hoverHexColor);

            this.color = baseHexColor;
            this.targetColorRgb = this.baseColorRgb;
            this.animationProgress = 0; // 0 = base, 1 = hover
            this.lastInteractionTime = 0;
          }

          draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i + Math.PI / 6;
              const pointX = this.x + hexSize * Math.cos(angle);
              const pointY = this.y + hexSize * Math.sin(angle);
              if (i === 0) ctx.moveTo(pointX, pointY);
              else ctx.lineTo(pointX, pointY);
            }
            ctx.closePath();
            ctx.fill();
          }

          update() {
            const now = Date.now();

            // If currently aiming for hover color
            if (this.targetColorRgb === this.hoverColorRgb) {
              this.animationProgress = Math.min(
                1,
                this.animationProgress + animationSpeed,
              );
            } else {
              // If currently aiming for base color
              if (now - this.lastInteractionTime > fadeDelay) {
                this.animationProgress = Math.max(
                  0,
                  this.animationProgress - animationSpeed,
                );
              }
            }

            // Interpolate color
            const currentRgb = hexToRgb(this.color); // Get current rendered RGB
            const startRgb = this.baseColorRgb;
            const endRgb = this.hoverColorRgb;

            const r = Math.round(
              startRgb.r + (endRgb.r - startRgb.r) * this.animationProgress,
            );
            const g = Math.round(
              startRgb.g + (endRgb.g - startRgb.g) * this.animationProgress,
            );
            const b = Math.round(
              startRgb.b + (endRgb.b - startRgb.b) * this.animationProgress,
            );
            this.color = `rgb(${r},${g},${b})`;
          }

          isMouseOver(mx, my) {
            if (
              mx < this.x - hexWidth / 2 ||
              mx > this.x + hexWidth / 2 ||
              my < this.y - hexHeight / 2 ||
              my > this.y + hexHeight / 2
            ) {
              return false;
            }
            const dx = Math.abs(mx - this.x);
            const dy = Math.abs(my - this.y);
            if (dx > hexWidth / 2 || dy > hexHeight / 2) return false;
            return (
              dy <= hexSize * 0.75 &&
              dx <= hexWidth / 2 &&
              (hexSize * 0.75 - dy) * Math.sqrt(3) > dx - hexSize * 0.5
            );
          }

          setHover(isHovered) {
            if (isHovered) {
              this.targetColorRgb = this.hoverColorRgb;
              this.lastInteractionTime = Date.now();
            } else {
              this.targetColorRgb = this.baseColorRgb;
            }
          }

          toBaseColor() {
            // Helper to directly set target to base
            return this.baseColorRgb;
          }
        }

        function initHexagons() {
          hexagons = [];
          const paddingX = hexWidth;
          const paddingY = hexHeight;

          const startX = -paddingX;
          const endX = width + paddingX;
          const startY = -paddingY;
          const endY = height + paddingY;

          for (let r = 0; ; r++) {
            const y = r * hexHeight * 0.75;
            if (y - hexHeight > endY) break;

            for (let q = 0; ; q++) {
              const xOffset = r % 2 === 0 ? 0 : hexWidth / 2;
              const x = q * hexWidth + xOffset;
              if (x - hexWidth > endX) break;
              hexagons.push(new Hexagon(x, y, q, r));
            }
          }
        }

        function resizeCanvas() {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
          initHexagons();
          updateThemeColors(currentTheme);
        }

        // Centralized function to handle mouse/virtual mouse position updates
        function handlePointerUpdate(x, y) {
          mouseX = x;
          mouseY = y;

          let currentHoveredHex = null;
          for (let i = 0; i < hexagons.length; i++) {
            if (hexagons[i].isMouseOver(mouseX, mouseY)) {
              currentHoveredHex = hexagons[i];
              break;
            }
          }

          if (currentHoveredHex && currentHoveredHex !== lastHoveredHex) {
            if (lastHoveredHex) {
              lastHoveredHex.setHover(false);
            }
            currentHoveredHex.setHover(true);
            lastHoveredHex = currentHoveredHex;
          } else if (!currentHoveredHex && lastHoveredHex) {
            lastHoveredHex.setHover(false);
            lastHoveredHex = null;
          }
        }

        function animate() {
          ctx.clearRect(0, 0, width, height);

          // Update virtual mouse position
          virtualMouseUpdateCounter++;
          if (virtualMouseUpdateCounter >= virtualMouseUpdateInterval) {
            virtualMouseDirectionX = Math.random() > 0.5 ? 1 : -1;
            virtualMouseDirectionY = Math.random() > 0.5 ? 1 : -1;
            virtualMouseUpdateCounter = 0;
          }

          // Move virtual mouse
          virtualMouseX += virtualMouseSpeed * virtualMouseDirectionX;
          virtualMouseY += virtualMouseSpeed * virtualMouseDirectionY;

          // Boundary checks for virtual mouse
          if (virtualMouseX < 0 || virtualMouseX > width) {
            virtualMouseDirectionX *= -1;
            virtualMouseX = Math.max(0, Math.min(width, virtualMouseX)); // Clamp within bounds
          }
          if (virtualMouseY < 0 || virtualMouseY > height) {
            virtualMouseDirectionY *= -1;
            virtualMouseY = Math.max(0, Math.min(height, virtualMouseY)); // Clamp within bounds
          }

          // Use the virtual mouse position for animation if no real mouse movement
          if (document.activeElement !== document.body) {
            // Check if user is interacting with form elements etc.
            handlePointerUpdate(virtualMouseX, virtualMouseY);
          } else {
            // Only use real mouse if it's currently moving (or very recently moved)
            // You might want a timer here to switch between real/virtual mouse
            // For simplicity, I'm letting real mouse override immediately.
          }

          hexagons.forEach((hex) => {
            hex.update();
            hex.draw();
          });

          requestAnimationFrame(animate);
        }

        window.addEventListener("resize", resizeCanvas);

        // Modify the mousemove listener: it now just calls the centralized handler
        document.addEventListener("mousemove", (e) => {
          // When real mouse moves, override virtual mouse position
          virtualMouseX = e.clientX;
          virtualMouseY = e.clientY;
          handlePointerUpdate(e.clientX, e.clientY);
        });

        const initialTheme =
          localStorage.getItem("theme") ||
          (prefersDarkScheme.matches ? "dark" : "light");
        resizeCanvas();
        updateThemeColors(initialTheme);

        // Initialize virtual mouse position
        virtualMouseX = width / 2;
        virtualMouseY = height / 2;

        animate();

        return {
          updateTheme: updateThemeColors,
        };
      })();
    </script>
  </body>
</html>
